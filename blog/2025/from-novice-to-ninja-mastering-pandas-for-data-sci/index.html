<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> From Novice to Ninja: Mastering Pandas for Data Science | Adarsh Nair </title> <meta name="author" content="Adarsh Nair"> <meta name="description" content="A deep dive into machine learning, AI, and data science. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/blog/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/blog/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/blog/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/blog/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://adarshnair.online/blog/blog/blog/2025/from-novice-to-ninja-mastering-pandas-for-data-sci/"> <script src="/blog/assets/js/theme.js?v=5fea5159b787642c1bbc1f334d60f883"></script> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://adarshnair.online" rel="external nofollow noopener" target="_blank"> Adarsh Nair </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/blog/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="https://adarshnair.online/books/" rel="external nofollow noopener" target="_blank">books </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">From Novice to Ninja: Mastering Pandas for Data Science</h1> <p class="post-meta"> Created on October 23, 2025 by Adarsh Nair </p> <p class="post-tags"> <a href="/blog/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/blog/tag/pandas"> <i class="fa-solid fa-hashtag fa-sm"></i> Pandas</a>   <a href="/blog/blog/tag/data-science"> <i class="fa-solid fa-hashtag fa-sm"></i> Data Science</a>   <a href="/blog/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> Python</a>   <a href="/blog/blog/tag/data-wrangling"> <i class="fa-solid fa-hashtag fa-sm"></i> Data Wrangling</a>   <a href="/blog/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> Optimization</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Hey everyone!</p> <p>If you’re diving into the exciting world of data science, you’ve undoubtedly encountered Pandas. It’s that friendly, powerful Python library that lets us manipulate tabular data like a spreadsheet on steroids. I remember when I first started, Pandas felt like magic – suddenly, I could load huge datasets, filter rows, and calculate averages with just a few lines of code. It was a game-changer!</p> <p>But, as with any powerful tool, there’s a learning curve. There are “good enough” ways to do things, and then there are <em>better</em>, more efficient, and often more elegant ways. Over my journey, I’ve had countless “aha!” moments discovering little tricks and best practices that completely transformed how I approached data wrangling. These aren’t just about writing less code; they’re about writing <em>faster</em> code, <em>cleaner</em> code, and ultimately, making your data science workflow a joy rather than a struggle.</p> <p>Today, I want to share some of my favorite Pandas tips that helped me level up my game, and I hope they do the same for you. Think of this as me sharing my personal journal of Pandas discoveries – accessible enough if you’re just starting, but deep enough to make you think about how you’re currently tackling your data.</p> <p>Let’s get started!</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">timeit</span> <span class="c1"># For performance benchmarking
</span></code></pre></div></div> <h3 id="tip-1-the-vectorization-superpower--ditch-the-loops">Tip 1: The Vectorization Superpower – Ditch the Loops!</h3> <p>This is probably the most crucial tip for performance in Pandas. When you first learn Python, looping through lists or arrays is natural. But with Pandas (and NumPy, which it’s built upon), loops are almost always the <em>slowest</em> way to do things.</p> <p><strong>What is Vectorization?</strong> Imagine you have a big team of workers, and you need to perform the same task on many items.</p> <ul> <li> <strong>Looping:</strong> You tell one worker, “Take this item, do task A. Now take the next item, do task A…”</li> <li> <strong>Vectorization:</strong> You tell the whole team, “Everybody, take one item and do task A <em>simultaneously</em>.”</li> </ul> <p>In Pandas, vectorization means performing operations on entire Series or DataFrames at once, rather than element by element. Pandas and NumPy leverage highly optimized C/Cython code under the hood, which means vectorized operations are incredibly fast, often utilizing your computer’s low-level processing capabilities (like SIMD instructions) that a Python <code class="language-plaintext highlighter-rouge">for</code> loop simply can’t match.</p> <p><strong>The “Bad” Way (Looping):</strong></p> <p>Let’s say we want to square every number in a column.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a large DataFrame
</span><span class="n">df_size</span> <span class="o">=</span> <span class="mi">1_000_000</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">({</span><span class="sh">'</span><span class="s">numbers</span><span class="sh">'</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">df_size</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">})</span>

<span class="c1"># Using a Python loop (don't do this!)
</span><span class="k">def</span> <span class="nf">square_loop</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">numbers</span><span class="sh">'</span><span class="p">]:</span>
        <span class="n">results</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">squared_loop</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
    <span class="k">return</span> <span class="n">df</span>

<span class="c1"># Using .apply() (better, but often not the best)
</span><span class="k">def</span> <span class="nf">square_apply</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">squared_apply</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">numbers</span><span class="sh">'</span><span class="p">].</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>

<span class="c1"># Using vectorization (the Pandas way!)
</span><span class="k">def</span> <span class="nf">square_vectorized</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">squared_vectorized</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">numbers</span><span class="sh">'</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">df</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Benchmarking performance:</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Measure loop performance
</span><span class="n">loop_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">square_loop</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="nf">copy</span><span class="p">()),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Looping time: </span><span class="si">{</span><span class="n">loop_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Measure apply performance
</span><span class="n">apply_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">square_apply</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="nf">copy</span><span class="p">()),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">.apply() time: </span><span class="si">{</span><span class="n">apply_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Measure vectorized performance
</span><span class="n">vectorized_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">square_vectorized</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="nf">copy</span><span class="p">()),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Vectorized time: </span><span class="si">{</span><span class="n">vectorized_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>You’ll notice the vectorized approach is orders of magnitude faster. For a million rows, loops can take seconds, <code class="language-plaintext highlighter-rouge">.apply()</code> can take hundreds of milliseconds, but vectorization often finishes in milliseconds. This isn’t a small difference; it can be the difference between your code running in minutes or hours!</p> <p><strong>When to use <code class="language-plaintext highlighter-rouge">.apply()</code>?</strong> While vectorization is king, <code class="language-plaintext highlighter-rouge">.apply()</code> still has its place for more complex, row-wise or element-wise operations that <em>cannot</em> be easily expressed with vectorized Pandas/NumPy functions. If your function involves conditional logic, custom string parsing, or interactions between multiple columns in a way that isn’t directly supported by Pandas operations, <code class="language-plaintext highlighter-rouge">.apply()</code> is your go-to. Just remember to always ask yourself: “Can I vectorize this first?”</p> <h3 id="tip-2-mastering-data-selection-with-loc-iloc-and-">Tip 2: Mastering Data Selection with <code class="language-plaintext highlighter-rouge">.loc</code>, <code class="language-plaintext highlighter-rouge">.iloc</code>, and <code class="language-plaintext highlighter-rouge">[]</code> </h3> <p>Selecting data is fundamental, and Pandas offers a few powerful ways to do it. Understanding the difference between <code class="language-plaintext highlighter-rouge">.loc</code>, <code class="language-plaintext highlighter-rouge">.iloc</code>, and the basic <code class="language-plaintext highlighter-rouge">[]</code> operator is crucial for writing correct and robust code, especially as your data gets more complex.</p> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">.loc</code> (Label-based Indexing):</strong> Use <code class="language-plaintext highlighter-rouge">.loc</code> when you want to select data based on its <em>labels</em> (row labels and column names). It’s inclusive on both ends for slices.</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">city</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">New York</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Los Angeles</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Chicago</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Houston</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Phoenix</span><span class="sh">'</span><span class="p">],</span>
        <span class="sh">'</span><span class="s">population</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mf">8.4</span><span class="p">,</span> <span class="mf">3.9</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">],</span>
        <span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">NY</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">CA</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">IL</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">TX</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">AZ</span><span class="sh">'</span><span class="p">],</span>
        <span class="sh">'</span><span class="s">area_sq_mi</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">302</span><span class="p">,</span> <span class="mi">469</span><span class="p">,</span> <span class="mi">227</span><span class="p">,</span> <span class="mi">637</span><span class="p">,</span> <span class="mi">517</span><span class="p">]}</span>
<span class="n">cities_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">NYC</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">LA</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">CHI</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">HOU</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">PHX</span><span class="sh">'</span><span class="p">])</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Original DataFrame:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">cities_df</span><span class="p">)</span>

<span class="c1"># Select row(s) by index label, column(s) by column label
# Select 'LA' and 'HOU' rows, and 'population' and 'state' columns
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">.loc for specific rows and columns:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
      <span class="n">cities_df</span><span class="p">.</span><span class="n">loc</span><span class="p">[[</span><span class="sh">'</span><span class="s">LA</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">HOU</span><span class="sh">'</span><span class="p">],</span> <span class="p">[</span><span class="sh">'</span><span class="s">population</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]])</span>

<span class="c1"># Select all rows where population &gt; 3 million, and only 'city' and 'state' columns
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">.loc with boolean indexing and column labels:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
      <span class="n">cities_df</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cities_df</span><span class="p">[</span><span class="sh">'</span><span class="s">population</span><span class="sh">'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="sh">'</span><span class="s">city</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]])</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">.iloc</code> (Integer-position based Indexing):</strong> Use <code class="language-plaintext highlighter-rouge">.iloc</code> when you want to select data based on its <em>integer positions</em> (0-indexed). Think of it like indexing a list or NumPy array. It’s exclusive on the end for slices (just like Python lists).</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1"># Select the first two rows and the first three columns
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">.iloc for first two rows, first three columns:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
      <span class="n">cities_df</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># 0:2 means rows 0, 1; 0:3 means cols 0, 1, 2
</span>
<span class="c1"># Select the last row and the last column
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">.iloc for last row and last column:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
      <span class="n">cities_df</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">[]</code> (The “Ambiguous” Operator):</strong> The <code class="language-plaintext highlighter-rouge">[]</code> operator is versatile but can be confusing because its behavior changes based on what you pass to it:</p> <ul> <li> <strong>Single string/list of strings:</strong> Selects columns.</li> <li> <strong>Boolean Series:</strong> Filters rows.</li> <li> <strong>Slice (e.g., <code class="language-plaintext highlighter-rouge">0:5</code>):</strong> If the index is integer-based, it selects rows by position. If the index is label-based, it selects rows by label (inclusive!). This is where the ambiguity often arises.</li> </ul> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1"># Select a single column
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">[] for a single column:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">cities_df</span><span class="p">[</span><span class="sh">'</span><span class="s">population</span><span class="sh">'</span><span class="p">].</span><span class="nf">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># Select multiple columns
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">[] for multiple columns:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">cities_df</span><span class="p">[[</span><span class="sh">'</span><span class="s">city</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">state</span><span class="sh">'</span><span class="p">]].</span><span class="nf">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># Boolean indexing (filters rows)
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">[] for boolean indexing (population &lt; 2M):</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
      <span class="n">cities_df</span><span class="p">[</span><span class="n">cities_df</span><span class="p">[</span><span class="sh">'</span><span class="s">population</span><span class="sh">'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">])</span>

<span class="c1"># Slicing rows (behaves like .loc if index is labels, like .iloc if index is integer position)
# Be careful here! If you have a custom label index, slicing like [0:2] will try to find labels '0', '1'.
# For our 'NYC', 'LA' etc. index, it tries to slice by label:
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">[] for label-based row slicing (inclusive end!):</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span>
      <span class="n">cities_df</span><span class="p">[</span><span class="sh">'</span><span class="s">NYC</span><span class="sh">'</span><span class="p">:</span><span class="sh">'</span><span class="s">CHI</span><span class="sh">'</span><span class="p">])</span> <span class="c1"># This includes 'NYC', 'LA', 'CHI'
</span>
<span class="c1"># If the index was pd.RangeIndex(0,5), then cities_df[0:2] would get rows 0, 1
</span></code></pre></div> </div> </li> </ul> <p><strong>My Recommendation:</strong> For explicit clarity and to avoid potential bugs, always prefer <code class="language-plaintext highlighter-rouge">.loc</code> for label-based selection and <code class="language-plaintext highlighter-rouge">.iloc</code> for integer-position based selection. Use <code class="language-plaintext highlighter-rouge">[]</code> primarily for selecting columns or boolean filtering rows.</p> <h3 id="tip-3-the-art-of-method-chaining-with-pipe-and-assign">Tip 3: The Art of Method Chaining with <code class="language-plaintext highlighter-rouge">pipe()</code> and <code class="language-plaintext highlighter-rouge">assign()</code> </h3> <p>As your data cleaning and preprocessing steps grow, your code can become a messy cascade of intermediate variables: <code class="language-plaintext highlighter-rouge">df_step1 = df.do_something()</code>, <code class="language-plaintext highlighter-rouge">df_step2 = df_step1.do_another_thing()</code>, etc. This breaks readability and makes debugging harder.</p> <p>Enter <strong>method chaining</strong>! Most Pandas operations return a DataFrame or Series, allowing you to chain multiple operations together in a single, readable sequence.</p> <p><strong><code class="language-plaintext highlighter-rouge">assign()</code> for New Columns:</strong> <code class="language-plaintext highlighter-rouge">assign()</code> is fantastic for creating new columns within a method chain. It returns a <em>new</em> DataFrame with the new columns added, without modifying the original in-place. This immutability is key for chaining.</p> <p>Let’s imagine we have student grades and want to calculate weighted averages and assign letter grades.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">grades_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">({</span>
    <span class="sh">'</span><span class="s">student_id</span><span class="sh">'</span><span class="p">:</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
    <span class="sh">'</span><span class="s">exam1</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">85</span><span class="p">,</span> <span class="mi">92</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">95</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">exam2</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">90</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">project</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">70</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">88</span><span class="p">]</span>
<span class="p">})</span>

<span class="c1"># Weights for grades
</span><span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">exam1</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="sh">'</span><span class="s">exam2</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.4</span><span class="p">,</span> <span class="sh">'</span><span class="s">project</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Original Grades:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">grades_df</span><span class="p">)</span>

<span class="n">processed_grades</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">grades_df</span>
    <span class="p">.</span><span class="nf">assign</span><span class="p">(</span>
        <span class="n">weighted_average</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">exam1</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="sh">'</span><span class="s">exam1</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">exam2</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="sh">'</span><span class="s">exam2</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">project</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="sh">'</span><span class="s">project</span><span class="sh">'</span><span class="p">]),</span>
        <span class="n">passed</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">weighted_average</span><span class="sh">'</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">70</span> <span class="c1"># Simple pass/fail
</span>    <span class="p">)</span>
    <span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="sh">'</span><span class="s">weighted_average</span><span class="sh">'</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Processed Grades (with .assign() and chaining):</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">processed_grades</span><span class="p">)</span>
</code></pre></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">lambda df: ...</code> lets you refer to the DataFrame <em>within</em> the <code class="language-plaintext highlighter-rouge">assign()</code> call, even to columns just created in the same <code class="language-plaintext highlighter-rouge">assign()</code> step (like <code class="language-plaintext highlighter-rouge">weighted_average</code> being used for <code class="language-plaintext highlighter-rouge">passed</code>). This makes complex calculations very clean.</p> <p><strong><code class="language-plaintext highlighter-rouge">pipe()</code> for Custom Functions:</strong> Sometimes you have a custom function that takes a DataFrame as input but doesn’t necessarily fit into the standard Pandas method chain. Or maybe it’s a function that doesn’t return a DataFrame, but you want to insert it into a chain. This is where <code class="language-plaintext highlighter-rouge">pipe()</code> shines. It allows you to inject any function that expects a DataFrame (or Series) as its first argument into your chain.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">highlight_top_students</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Highlights the top N students based on weighted_average.</span><span class="sh">"""</span>
    <span class="n">top_students</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="nf">nlargest</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="sh">'</span><span class="s">weighted_average</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">--- Top </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s"> Students ---</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">top_students</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span> <span class="c1"># Return the original df to continue the chain
</span>
<span class="c1"># Let's add a `pipe` call to our previous chain
</span><span class="n">final_grades</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">grades_df</span>
    <span class="p">.</span><span class="nf">assign</span><span class="p">(</span>
        <span class="n">weighted_average</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">exam1</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="sh">'</span><span class="s">exam1</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">exam2</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="sh">'</span><span class="s">exam2</span><span class="sh">'</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">project</span><span class="sh">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="sh">'</span><span class="s">project</span><span class="sh">'</span><span class="p">]),</span>
        <span class="n">passed</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="sh">'</span><span class="s">weighted_average</span><span class="sh">'</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">70</span>
    <span class="p">)</span>
    <span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="n">highlight_top_students</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Inject our custom function
</span>    <span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="sh">'</span><span class="s">weighted_average</span><span class="sh">'</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Final Grades (after highlighting top students with .pipe()):</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">final_grades</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">pipe()</code> is incredibly flexible for integrating custom logic seamlessly into your processing pipeline, making your code more readable and modular.</p> <h3 id="tip-4-efficient-data-reshaping-melt-and-pivot_table">Tip 4: Efficient Data Reshaping: <code class="language-plaintext highlighter-rouge">melt()</code> and <code class="language-plaintext highlighter-rouge">pivot_table()</code> </h3> <p>Data rarely comes in the exact shape you need for analysis or modeling. <code class="language-plaintext highlighter-rouge">melt()</code> and <code class="language-plaintext highlighter-rouge">pivot_table()</code> are two essential functions for transforming your data between “wide” and “long” formats.</p> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">melt()</code> (Wide to Long):</strong> Imagine you have survey data where each column represents a different question’s response, and you want to analyze all responses in a single column. <code class="language-plaintext highlighter-rouge">melt()</code> “unpivots” columns into rows.</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">sales_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">({</span>
    <span class="sh">'</span><span class="s">region</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">East</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">West</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">North</span><span class="sh">'</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">Q1_2023_Sales</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">120</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">Q2_2023_Sales</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">110</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">130</span><span class="p">],</span>
    <span class="sh">'</span><span class="s">Q3_2023_Sales</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="mi">110</span><span class="p">]</span>
<span class="p">})</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Original Wide Sales Data:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">sales_df</span><span class="p">)</span>

<span class="c1"># Melt the sales data to long format
</span><span class="n">long_sales_df</span> <span class="o">=</span> <span class="n">sales_df</span><span class="p">.</span><span class="nf">melt</span><span class="p">(</span>
    <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">region</span><span class="sh">'</span><span class="p">],</span>                  <span class="c1"># Columns to keep as identifiers
</span>    <span class="n">var_name</span><span class="o">=</span><span class="sh">'</span><span class="s">quarter</span><span class="sh">'</span><span class="p">,</span>                  <span class="c1"># Name for the new variable column (was Q1_2023_Sales etc.)
</span>    <span class="n">value_name</span><span class="o">=</span><span class="sh">'</span><span class="s">sales_amount</span><span class="sh">'</span>            <span class="c1"># Name for the new value column (the sales figures)
</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Melted Long Sales Data:</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">long_sales_df</span><span class="p">)</span>
</code></pre></div> </div> <p>This transformed data is often much easier for plotting (e.g., showing sales trends over quarters) or for certain machine learning models that prefer a “long” format.</p> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">pivot_table()</code> (Long to Wide, with Aggregation):</strong> Now, what if you have data in a long format, and you want to summarize it and spread it out into a wide format? <code class="language-plaintext highlighter-rouge">pivot_table()</code> is your friend. It’s like a powerful version of Excel’s pivot tables.</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1"># Let's use our long_sales_df to pivot back, maybe aggregating by sum
</span><span class="n">pivoted_sales_df</span> <span class="o">=</span> <span class="n">long_sales_df</span><span class="p">.</span><span class="nf">pivot_table</span><span class="p">(</span>
    <span class="n">index</span><span class="o">=</span><span class="sh">'</span><span class="s">region</span><span class="sh">'</span><span class="p">,</span>                       <span class="c1"># Columns to use as new index
</span>    <span class="n">columns</span><span class="o">=</span><span class="sh">'</span><span class="s">quarter</span><span class="sh">'</span><span class="p">,</span>                    <span class="c1"># Columns to use as new column headers
</span>    <span class="n">values</span><span class="o">=</span><span class="sh">'</span><span class="s">sales_amount</span><span class="sh">'</span><span class="p">,</span>                <span class="c1"># Column(s) to aggregate and fill values
</span>    <span class="n">aggfunc</span><span class="o">=</span><span class="sh">'</span><span class="s">sum</span><span class="sh">'</span>                         <span class="c1"># How to aggregate if multiple values match
</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Pivoted Sales Data (sum of sales per region per quarter):</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="n">pivoted_sales_df</span><span class="p">)</span>

<span class="c1"># You can also pivot with multiple value columns or multiple aggregation functions
# E.g., if you had sales, profit, and wanted mean and sum.
</span></code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">pivot_table()</code> is incredibly versatile for creating summary tables, cross-tabulations, and reshaping data for specific analysis needs.</p> </li> </ul> <h3 id="tip-5-optimizing-memory-and-speed-with-categorical-dtype">Tip 5: Optimizing Memory and Speed with Categorical Dtype</h3> <p>For columns with a limited number of unique, non-numerical values (e.g., ‘gender’, ‘country’, ‘product_type’), Pandas’ <code class="language-plaintext highlighter-rouge">category</code> dtype can be a game-changer for both memory usage and performance.</p> <p><strong>How it Works:</strong> Instead of storing the actual string values repeatedly for each row, Pandas stores integers representing the categories and a mapping (a lookup table) from these integers back to the actual string labels. This is much more memory efficient, especially for columns with many duplicate values.</p> <p><strong>Example:</strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a DataFrame with a string column that has low cardinality
</span><span class="n">data_size</span> <span class="o">=</span> <span class="mi">1_000_000</span>
<span class="n">countries</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">USA</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Canada</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Mexico</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Germany</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">France</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Japan</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Australia</span><span class="sh">'</span><span class="p">]</span>
<span class="n">df_strings</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">({</span>
    <span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">:</span> <span class="nf">range</span><span class="p">(</span><span class="n">data_size</span><span class="p">),</span>
    <span class="sh">'</span><span class="s">country_str</span><span class="sh">'</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">countries</span><span class="p">,</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1"># Check memory usage for the string column
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Memory usage for </span><span class="sh">'</span><span class="s">country_str</span><span class="sh">'</span><span class="s"> (string): </span><span class="si">{</span><span class="n">df_strings</span><span class="p">[</span><span class="sh">'</span><span class="s">country_str</span><span class="sh">'</span><span class="p">].</span><span class="nf">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Convert to categorical type
</span><span class="n">df_categorical</span> <span class="o">=</span> <span class="n">df_strings</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>
<span class="n">df_categorical</span><span class="p">[</span><span class="sh">'</span><span class="s">country_cat</span><span class="sh">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_categorical</span><span class="p">[</span><span class="sh">'</span><span class="s">country_str</span><span class="sh">'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="sh">'</span><span class="s">category</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Check memory usage for the categorical column
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Memory usage for </span><span class="sh">'</span><span class="s">country_cat</span><span class="sh">'</span><span class="s"> (categorical): </span><span class="si">{</span><span class="n">df_categorical</span><span class="p">[</span><span class="sh">'</span><span class="s">country_cat</span><span class="sh">'</span><span class="p">].</span><span class="nf">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Performance benefits for operations like groupby
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">Benchmarking groupby performance:</span><span class="sh">"</span><span class="p">)</span>
<span class="n">string_groupby_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">df_strings</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="sh">'</span><span class="s">country_str</span><span class="sh">'</span><span class="p">).</span><span class="nf">size</span><span class="p">(),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">String groupby time: </span><span class="si">{</span><span class="n">string_groupby_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="n">categorical_groupby_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">df_categorical</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="sh">'</span><span class="s">country_cat</span><span class="sh">'</span><span class="p">).</span><span class="nf">size</span><span class="p">(),</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Categorical groupby time: </span><span class="si">{</span><span class="n">categorical_groupby_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>You’ll often see a significant reduction in memory footprint and a speedup in operations like <code class="language-plaintext highlighter-rouge">groupby()</code>, <code class="language-plaintext highlighter-rouge">value_counts()</code>, and comparisons when using categorical data. This is particularly useful for very large datasets where memory becomes a constraint.</p> <p><strong>When to Use/Not Use:</strong></p> <ul> <li> <strong>Use when:</strong> A column has a relatively small, fixed number of unique values (low cardinality).</li> <li> <strong>Don’t use when:</strong> A column has many unique values (high cardinality), or if the data is inherently numerical and you need to perform numerical operations on it. Converting high-cardinality strings to categorical can actually increase memory usage due to the overhead of the categories object.</li> </ul> <h3 id="final-thoughts-embrace-the-journey">Final Thoughts: Embrace the Journey!</h3> <p>These are just a handful of the many powerful features Pandas offers. My biggest advice is to keep exploring, keep experimenting, and don’t be afraid to read the documentation (it’s really good!).</p> <p>The journey from a Pandas novice to a ninja is less about memorizing every function and more about understanding the core philosophies:</p> <ol> <li> <strong>Vectorization first:</strong> Always try to use vectorized operations.</li> <li> <strong>Explicit is better than implicit:</strong> Use <code class="language-plaintext highlighter-rouge">.loc</code> and <code class="language-plaintext highlighter-rouge">.iloc</code> for clarity.</li> <li> <strong>Readability matters:</strong> Chain your methods and use <code class="language-plaintext highlighter-rouge">assign()</code>/<code class="language-plaintext highlighter-rouge">pipe()</code> to keep your code clean.</li> <li> <strong>Efficiency counts:</strong> Understand data types and use them wisely for memory and speed.</li> </ol> <p>Pandas is an incredible library that will be a constant companion in your data science adventures. The more you master its intricacies, the more time you’ll save, and the more robust and elegant your data solutions will become.</p> <p>Happy data wrangling!</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/cracking-the-ai-black-box-why-explainable-ai-xai-i/">Cracking the AI Black Box: Why Explainable AI (XAI) is Our Superpower</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/the-secret-life-of-states-how-markov-chains-predic/">The Secret Life of States: How Markov Chains Predict Our Next Move (Without Remembering the Past!)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/gradient-descent-unpacking-the-engine-of-machine-l/">Gradient Descent: Unpacking the Engine of Machine Learning</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Adarsh Nair. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/blog/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/blog/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/blog/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/blog/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/blog/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/blog/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/blog/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/blog/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/blog/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/blog/assets/js/search-data.js"></script> <script src="/blog/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>