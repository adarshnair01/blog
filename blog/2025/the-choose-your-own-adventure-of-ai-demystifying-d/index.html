<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> The 'Choose Your Own Adventure' of AI: Demystifying Decision Trees | Adarsh Nair </title> <meta name="author" content="Adarsh Nair"> <meta name="description" content="A deep dive into machine learning, AI, and data science. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/blog/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/blog/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/blog/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/blog/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://adarshnair.online/blog/blog/blog/2025/the-choose-your-own-adventure-of-ai-demystifying-d/"> <script src="/blog/assets/js/theme.js?v=5fea5159b787642c1bbc1f334d60f883"></script> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://adarshnair.online" rel="external nofollow noopener" target="_blank"> Adarsh Nair </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/blog/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="https://adarshnair.online/books/" rel="external nofollow noopener" target="_blank">books </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">The 'Choose Your Own Adventure' of AI: Demystifying Decision Trees</h1> <p class="post-meta"> Created on January 19, 2025 by Adarsh Nair </p> <p class="post-tags"> <a href="/blog/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/blog/tag/machine-learning"> <i class="fa-solid fa-hashtag fa-sm"></i> Machine Learning</a>   <a href="/blog/blog/tag/decision-trees"> <i class="fa-solid fa-hashtag fa-sm"></i> Decision Trees</a>   <a href="/blog/blog/tag/ai-explained"> <i class="fa-solid fa-hashtag fa-sm"></i> AI Explained</a>   <a href="/blog/blog/tag/supervised-learning"> <i class="fa-solid fa-hashtag fa-sm"></i> Supervised Learning</a>   <a href="/blog/blog/tag/data-science"> <i class="fa-solid fa-hashtag fa-sm"></i> Data Science</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Hello, fellow data explorers!</p> <p>Have you ever found yourself making a decision by mentally drawing a flowchart? “If it’s sunny, I’ll go for a run. If it’s cloudy, but not raining, maybe I’ll cycle. If it’s raining, I’ll read a book.” We do this all the time, breaking down complex choices into a series of simpler, yes-or-no questions. It’s an incredibly intuitive way to navigate the world.</p> <p>What if I told you that one of the most fundamental and powerful algorithms in Machine Learning mimics this exact human thought process? Welcome to the fascinating world of <strong>Decision Trees</strong>. They’re like the “Choose Your Own Adventure” books of artificial intelligence, guiding a model through a series of choices to arrive at a prediction.</p> <h3 id="what-exactly-is-a-decision-tree">What Exactly <em>Is</em> a Decision Tree?</h3> <p>At its core, a Decision Tree is a non-parametric supervised learning algorithm used for both <strong>classification</strong> (predicting a category, like “spam” or “not spam”) and <strong>regression</strong> (predicting a numerical value, like house price). Think of it as a flowchart where each internal node represents a “test” on an attribute (e.g., “Is the weather sunny?”), each branch represents the outcome of that test, and each leaf node represents a class label (for classification) or a numerical value (for regression).</p> <p>Let’s break down its components with an example: Imagine you’re trying to decide if you should pack an umbrella.</p> <ul> <li> <strong>Root Node:</strong> This is where the journey begins, the very first question. In our umbrella example, maybe it’s “Is the sky cloudy?”</li> <li> <strong>Internal Nodes (Decision Nodes):</strong> These are subsequent questions based on the answers to previous ones. If the sky is cloudy, the next question might be “Is there a high chance of rain?”</li> <li> <strong>Branches (Edges):</strong> These are the paths taken based on the answer to a node’s question. A “yes” or “no” branch.</li> <li> <strong>Leaf Nodes (Terminal Nodes):</strong> These are the final destinations, the predictions or decisions. If the chance of rain is high, the leaf node says “Pack Umbrella.” If not, “Don’t Pack Umbrella.”</li> </ul> <p>Visually, a decision tree looks exactly like an inverted tree, with the root at the top and the leaves at the bottom. It’s incredibly intuitive, which is one of its biggest strengths!</p> <h3 id="how-do-decision-trees-learn-the-art-of-splitting">How Do Decision Trees “Learn”? The Art of Splitting</h3> <p>This is where the magic (and the math!) happens. Decision Trees don’t just randomly ask questions. They learn <em>which</em> questions to ask and <em>in what order</em> to make the best predictions. The core idea is to recursively split the data into subsets that are as “pure” as possible.</p> <p>What does “pure” mean in this context? Imagine a node in our tree. If all the data points that reach this node belong to the same class (e.g., everyone here <em>will</em> pack an umbrella), then that node is perfectly pure, and it can be a leaf node. If the data points are mixed (some will pack, some won’t), the node is impure, and we need to split it further.</p> <p>The algorithm’s goal is to find the best split at each step – the question that divides the data into the most homogeneous (pure) groups. We achieve this by evaluating different splitting criteria, primarily:</p> <ol> <li><strong>Gini Impurity</strong></li> <li><strong>Entropy and Information Gain</strong></li> </ol> <p>Let’s dive into these. Don’t worry, we’ll keep it clear!</p> <h4 id="1-gini-impurity">1. Gini Impurity</h4> <p>Gini Impurity is a measure of how often a randomly chosen element from the set would be incorrectly classified if it were randomly labeled according to the distribution of labels in the subset. A Gini Impurity of 0 means the node is perfectly pure (all elements belong to the same class). A Gini Impurity of 0.5 (for a binary classification problem) means an equal split, maximum impurity.</p> <p>The formula for Gini Impurity for a node $t$ is:</p> <p>$G(t) = 1 - \sum_{i=1}^{c} p_i^2$</p> <p>Where:</p> <ul> <li>$c$ is the number of classes.</li> <li>$p_i$ is the probability (or proportion) of class $i$ in the node $t$.</li> </ul> <p><strong>How it works:</strong> The algorithm calculates the Gini Impurity for the current node. Then, for every possible split, it calculates the Gini Impurity of the resulting child nodes. It chooses the split that leads to the greatest <strong>reduction</strong> in Gini Impurity (or the lowest weighted average Gini Impurity of the child nodes). This reduction is often called Gini Gain.</p> <p>Let’s say a parent node has 10 samples: 5 “Pack Umbrella” and 5 “Don’t Pack Umbrella.” $p_{pack} = 5/10 = 0.5$ $p_{don’t pack} = 5/10 = 0.5$ $G(parent) = 1 - (0.5^2 + 0.5^2) = 1 - (0.25 + 0.25) = 1 - 0.5 = 0.5$ (Maximum impurity!)</p> <p>Now, imagine we split by “Is there a high chance of rain?”.</p> <ul> <li> <strong>Child Node 1 (“High Chance of Rain = Yes”):</strong> Has 6 samples: 5 “Pack Umbrella”, 1 “Don’t Pack Umbrella.” $p_{pack} = 5/6$, $p_{don’t pack} = 1/6$ $G(child_1) = 1 - ((5/6)^2 + (1/6)^2) = 1 - (25/36 + 1/36) = 1 - 26/36 \approx 0.278$</li> <li> <strong>Child Node 2 (“High Chance of Rain = No”):</strong> Has 4 samples: 0 “Pack Umbrella”, 4 “Don’t Pack Umbrella.” $p_{pack} = 0/4$, $p_{don’t pack} = 4/4 = 1$ $G(child_2) = 1 - (0^2 + 1^2) = 1 - 1 = 0$ (Perfectly pure!)</li> </ul> <p>The weighted average Gini for this split would be: $(6/10) * G(child_1) + (4/10) * G(child_2) = 0.6 * 0.278 + 0.4 * 0 = 0.1668$</p> <p>Since $0.1668 &lt; 0.5$, this is a good split, as it reduced impurity significantly! The algorithm would continue searching for the <em>best</em> such reduction.</p> <h4 id="2-entropy-and-information-gain">2. Entropy and Information Gain</h4> <p><strong>Entropy</strong> is a concept from information theory that measures the disorder or unpredictability in a set of data. If a set is perfectly pure (all elements are the same), its entropy is 0. If it’s a perfect 50/50 split, its entropy is 1 (for binary classification), representing maximum disorder. Our goal is to reduce entropy as much as possible with each split.</p> <p>The formula for Entropy for a node $S$ is:</p> <p>$H(S) = - \sum_{i=1}^{c} p_i \log_2(p_i)$</p> <p>Where:</p> <ul> <li>$c$ is the number of classes.</li> <li>$p_i$ is the proportion of class $i$ in the node $S$.</li> </ul> <p><strong>Information Gain (IG)</strong> is the measure we actually use to pick the best split. It quantifies how much the entropy (disorder) is reduced after splitting the dataset based on an attribute. We want to maximize Information Gain.</p> <p>The formula for Information Gain when splitting set $S$ on attribute $A$ is:</p> <table> <tbody> <tr> <td>$IG(S, A) = H(S) - \sum_{v \in Values(A)} \frac{</td> <td>S_v</td> <td>}{</td> <td>S</td> <td>} H(S_v)$</td> </tr> </tbody> </table> <p>Where:</p> <ul> <li>$H(S)$ is the entropy of the parent set $S$.</li> <li>$Values(A)$ are the possible values for attribute $A$.</li> <li>$S_v$ is the subset of $S$ for which attribute $A$ has value $v$.</li> <li> <table> <tbody> <tr> <td>$\frac{</td> <td>S_v</td> <td>}{</td> <td>S</td> <td>}$ is the proportion of elements in $S$ that have value $v$ for attribute $A$ (it acts as a weight).</td> </tr> </tbody> </table> </li> <li>$H(S_v)$ is the entropy of the subset $S_v$.</li> </ul> <p>In simpler terms, Information Gain is the entropy of the parent node minus the <em>weighted average</em> entropy of the child nodes. The attribute that yields the highest Information Gain is chosen for the split.</p> <p><strong>Which to choose? Gini or Entropy?</strong> In practice, Gini Impurity and Entropy often lead to very similar trees. Gini is generally computationally faster as it doesn’t involve logarithms, making it a common default in many libraries (like scikit-learn). Entropy tends to favor more balanced splits, while Gini can sometimes isolate the majority class in one branch. However, the difference is usually minor.</p> <h3 id="the-tree-building-process-a-recursive-dance">The Tree Building Process: A Recursive Dance</h3> <p>The algorithm builds the tree recursively:</p> <ol> <li> <strong>Start at the Root:</strong> All training data begins at the root node.</li> <li> <strong>Evaluate All Possible Splits:</strong> For each available attribute, the algorithm considers all possible ways to split the data (e.g., for “temperature,” it might try splitting at 20°C, then 25°C, etc., finding the optimal threshold for numerical data).</li> <li> <strong>Calculate Impurity Reduction:</strong> It calculates the Information Gain or Gini Impurity reduction for each potential split.</li> <li> <strong>Choose the Best Split:</strong> The attribute and threshold that yield the maximum Information Gain (or minimum weighted impurity) are chosen for the current node.</li> <li> <strong>Create Child Nodes:</strong> The data is split into subsets based on the chosen attribute, and new child nodes are created.</li> <li> <strong>Recurse:</strong> Steps 2-5 are repeated for each child node, essentially building sub-trees.</li> <li> <strong>Stop When Pure or Limited:</strong> The recursion stops when: <ul> <li>A node becomes perfectly pure (all samples belong to the same class).</li> <li>No more attributes are left to split on.</li> <li>Pre-defined stopping criteria are met, such as a maximum tree depth, minimum number of samples required to make a split, or minimum number of samples in a leaf node. These are crucial for preventing overfitting.</li> </ul> </li> </ol> <h3 id="strengths-of-decision-trees">Strengths of Decision Trees</h3> <ul> <li> <strong>Intuitive &amp; Interpretable:</strong> This is perhaps their biggest superpower. You can literally draw them out and explain how a decision is made, even to a non-technical audience. It’s like having a crystal-clear policy document!</li> <li> <strong>No Feature Scaling Needed:</strong> Unlike many other algorithms (like SVMs or Neural Networks), Decision Trees don’t require you to normalize or standardize your data. They don’t care about the scale of your features.</li> <li> <strong>Handles Both Numerical &amp; Categorical Data:</strong> They can naturally work with both types of features, making them versatile.</li> <li> <strong>Can Handle Multi-Output Problems:</strong> A single tree can predict multiple dependent variables.</li> <li> <strong>Foundation for Ensembles:</strong> As we’ll see, single decision trees are the building blocks for much more powerful algorithms like Random Forests and Gradient Boosting.</li> </ul> <h3 id="weaknesses--challenges">Weaknesses &amp; Challenges</h3> <ul> <li> <strong>Prone to Overfitting:</strong> Without proper tuning and stopping criteria, a Decision Tree can grow very deep and complex, learning noise in the training data rather than the underlying patterns. This makes it perform poorly on unseen data. <ul> <li> <strong>Solution:</strong> <strong>Pruning</strong> (removing branches that don’t add significant predictive power) or setting <strong>maximum depth</strong> limits are common strategies.</li> </ul> </li> <li> <strong>Instability:</strong> Small changes in the training data can sometimes lead to a completely different tree structure, making them somewhat unstable.</li> <li> <strong>Bias Towards Dominant Classes:</strong> If there’s a significant class imbalance in your dataset, the tree might be biased towards the majority class.</li> <li> <strong>Local Optima:</strong> The greedy approach of selecting the best split at each step doesn’t guarantee the globally optimal tree. It makes the locally best decision.</li> </ul> <h3 id="real-world-applications">Real-World Applications</h3> <p>Decision Trees are used in countless applications across various industries:</p> <ul> <li> <strong>Medical Diagnosis:</strong> Identifying risk factors for diseases based on patient symptoms and medical history.</li> <li> <strong>Customer Churn Prediction:</strong> Predicting which customers are likely to leave a service.</li> <li> <strong>Credit Risk Assessment:</strong> Evaluating the likelihood of a loan applicant defaulting.</li> <li> <strong>Fraud Detection:</strong> Identifying suspicious transactions.</li> <li> <strong>Recommendation Systems:</strong> Guiding users through product choices.</li> </ul> <h3 id="beyond-a-single-tree-the-ensemble-revolution">Beyond a Single Tree: The Ensemble Revolution</h3> <p>While individual Decision Trees are powerful, their weaknesses (especially overfitting and instability) led to the development of <strong>ensemble methods</strong>. These techniques combine the predictions of multiple decision trees to create an even more robust and accurate model. Think of it like getting advice from a committee of experts rather than just one.</p> <p>The two most famous examples are:</p> <ul> <li> <strong>Random Forests:</strong> Builds an ensemble of many decision trees, each trained on a random subset of the data and a random subset of features. The final prediction is an average (for regression) or a majority vote (for classification) of all trees. This beautifully combats overfitting and instability.</li> <li> <strong>Gradient Boosting (e.g., XGBoost, LightGBM):</strong> Builds trees sequentially, where each new tree tries to correct the errors made by the previous ones. It’s like a team learning from its mistakes over and over again. These are often the go-to algorithms for tabular data.</li> </ul> <h3 id="conclusion">Conclusion</h3> <p>Decision Trees, with their intuitive, flowchart-like structure, offer a beautiful entry point into the world of machine learning. They show us that some of the most complex problems can be broken down into a series of simple, understandable questions. While a single tree might have its quirks, its underlying principle of recursively splitting data to reduce impurity is a fundamental concept that underpins much more sophisticated AI.</p> <p>So, the next time you find yourself making a choice by pondering a series of “if-then-else” scenarios, remember that you’re thinking just like an AI, and perhaps, just like a Decision Tree. And who knows, maybe you’ve just gained a new tool for your own data science adventure! Keep exploring, keep questioning, and keep learning!</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/cracking-the-ai-black-box-why-explainable-ai-xai-i/">Cracking the AI Black Box: Why Explainable AI (XAI) is Our Superpower</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/the-secret-life-of-states-how-markov-chains-predic/">The Secret Life of States: How Markov Chains Predict Our Next Move (Without Remembering the Past!)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/gradient-descent-unpacking-the-engine-of-machine-l/">Gradient Descent: Unpacking the Engine of Machine Learning</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Adarsh Nair. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/blog/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/blog/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/blog/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/blog/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/blog/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/blog/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/blog/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/blog/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/blog/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/blog/assets/js/search-data.js"></script> <script src="/blog/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>