<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Unleashing the Speed Demon: My Journey into NumPy Optimization | Adarsh Nair </title> <meta name="author" content="Adarsh Nair"> <meta name="description" content="A deep dive into machine learning, AI, and data science. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/blog/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/blog/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/blog/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/blog/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://adarshnair.online/blog/blog/blog/2024/unleashing-the-speed-demon-my-journey-into-numpy-o/"> <script src="/blog/assets/js/theme.js?v=5fea5159b787642c1bbc1f334d60f883"></script> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://adarshnair.online" rel="external nofollow noopener" target="_blank"> Adarsh Nair </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/blog/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="https://adarshnair.online/books/" rel="external nofollow noopener" target="_blank">books </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Unleashing the Speed Demon: My Journey into NumPy Optimization</h1> <p class="post-meta"> Created on August 09, 2024 by Adarsh Nair </p> <p class="post-tags"> <a href="/blog/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/blog/tag/numpy"> <i class="fa-solid fa-hashtag fa-sm"></i> NumPy</a>   <a href="/blog/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> Optimization</a>   <a href="/blog/blog/tag/data-science"> <i class="fa-solid fa-hashtag fa-sm"></i> Data Science</a>   <a href="/blog/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> Python</a>   <a href="/blog/blog/tag/performance"> <i class="fa-solid fa-hashtag fa-sm"></i> Performance</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>My hands hovered over the keyboard, a slight tremor of frustration running through me. The progress bar for my latest machine learning experiment – a rather ambitious clustering algorithm on a moderately sized dataset – was moving at a snail’s pace. Hours had turned into what felt like an eternity, and I knew deep down that this wasn’t how it was supposed to be. Python, with its reputation for being “slow,” was living up to the stereotype. Or was it?</p> <p>That day marked a turning point. It wasn’t Python’s fault entirely, nor NumPy’s. It was <em>my</em> understanding of how to wield these powerful tools effectively. I embarked on a quest to truly understand NumPy’s heart – its blazing fast core – and to identify the subtle pitfalls that could turn a potential speed demon into a sluggish slug. This blog post is my personal journal from that journey, sharing the ‘aha!’ moments and practical strategies I discovered. If you’ve ever stared blankly at a slow-running script, wondering if there’s a better way, then welcome, friend. Let’s make your code fly.</p> <h3 id="the-illusion-of-slowness-why-numpy-is-usually-fast">The Illusion of Slowness: Why NumPy is (Usually) Fast</h3> <p>Before we dive into optimization, let’s clarify something crucial: NumPy isn’t inherently slow. In fact, it’s one of the fastest numerical computing libraries available in <em>any</em> language. The secret lies beneath the surface.</p> <p>At its core, NumPy arrays are essentially contiguous blocks of memory, much like arrays in C or Fortran. When you perform an operation on a NumPy array (like adding two arrays together), NumPy doesn’t actually use Python’s slow, interpreted loops. Instead, it dispatches these operations to highly optimized, pre-compiled C, C++, or Fortran routines (often leveraging BLAS and LAPACK libraries). These low-level routines are designed to exploit modern CPU architectures, sometimes even parallelizing computations across multiple cores.</p> <p>Consider a simple array addition:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span>
<span class="n">a_python</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
<span class="n">b_python</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

<span class="n">a_numpy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">b_numpy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

<span class="c1"># Python list addition
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">c_python</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_python</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b_python</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Python list addition: </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># NumPy array addition
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">c_numpy</span> <span class="o">=</span> <span class="n">a_numpy</span> <span class="o">+</span> <span class="n">b_numpy</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">NumPy array addition: </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>When I first ran this, the difference blew my mind. The NumPy version wasn’t just <em>faster</em>, it was <em>orders of magnitude faster</em>. This is the magic of <strong>vectorization</strong>: performing operations on entire arrays at once, rather than element by element in Python loops.</p> <p>However, the magic can be broken. If you write code that <em>looks</em> like NumPy but forces it back into Python’s slow loops, or if you create too many temporary arrays, you lose the performance edge. My quest was about avoiding these traps.</p> <h3 id="my-optimization-playbook-strategies-for-speed">My Optimization Playbook: Strategies for Speed</h3> <p>Here are the key strategies I adopted to turn my NumPy code into a speed demon:</p> <h4 id="1-embrace-vectorization-like-your-performance-depends-on-it">1. Embrace Vectorization (Like Your Performance Depends On It)</h4> <p>This is the golden rule. Any time you find yourself writing a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates over a NumPy array’s elements, stop. There’s almost certainly a vectorized NumPy way to do it.</p> <p><strong>Example: Conditional Logic</strong></p> <p>Instead of:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Slow, unvectorized way
</span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">empty_like</span><span class="p">(</span><span class="n">my_array</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">my_array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">my_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div> <p>Use <code class="language-plaintext highlighter-rouge">np.where</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">-</span> <span class="mi">5</span> <span class="c1"># Array with positive and negative numbers
</span><span class="n">result_vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">my_array</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">my_array</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">my_array</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">np.where</code> applies the condition and then selects elements from the second or third arguments, all in optimized C code.</p> <p><strong>Example: Matrix Operations</strong></p> <p>If you’re doing linear algebra, always use NumPy’s built-in functions. For instance, matrix multiplication:</p> <p>Instead of (please, never do this!):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># VERY SLOW custom matrix multiplication
</span><span class="k">def</span> <span class="nf">matmul_slow</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">rows_A</span><span class="p">,</span> <span class="n">cols_A</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">shape</span>
    <span class="n">rows_B</span><span class="p">,</span> <span class="n">cols_B</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">cols_A</span> <span class="o">!=</span> <span class="n">rows_B</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">Matrices incompatible for multiplication</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">rows_A</span><span class="p">,</span> <span class="n">cols_B</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">rows_A</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">cols_B</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">cols_A</span><span class="p">):</span>
                <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">C</span>
</code></pre></div></div> <p>Use <code class="language-plaintext highlighter-rouge">np.dot</code> or the <code class="language-plaintext highlighter-rouge">@</code> operator:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

<span class="c1"># Fast way
</span><span class="n">C_fast</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">B</span>  <span class="c1"># Or np.dot(A, B) for older Python versions
</span></code></pre></div></div> <p>The formula for matrix multiplication itself, $C_{ij} = \sum_k A_{ik} B_{kj}$, is inherently a sum of products, which <code class="language-plaintext highlighter-rouge">np.dot</code> (and its underlying BLAS routines) is supremely optimized to handle.</p> <h4 id="2-beware-of-python-loops-and-how-numba-can-help">2. Beware of Python Loops (and How Numba Can Help)</h4> <p>Sometimes, a true vectorized solution is elusive, or the logic is too complex to fit into standard NumPy functions. This is where I discovered Numba. Numba is a JIT (Just-In-Time) compiler that translates a subset of Python code into fast machine code.</p> <p>Just add <code class="language-plaintext highlighter-rouge">@jit</code> (or <code class="language-plaintext highlighter-rouge">@njit</code> for nopython mode, which is even faster) above your function:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="k">def</span> <span class="nf">custom_complex_calculation_python</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># nopython=True ensures pure C-speed
</span><span class="k">def</span> <span class="nf">custom_complex_calculation_numba</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="nf">custom_complex_calculation_python</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Python loop (custom function): </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="nf">custom_complex_calculation_numba</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># First call compiles, subsequent calls are fast
</span><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Numba JIT (custom function): </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Numba gave me the best of both worlds: Python’s syntax and C’s speed for those tricky, unvectorizable parts.</p> <h4 id="3-understand-broadcasting-the-silent-workhorse">3. Understand Broadcasting: The Silent Workhorse</h4> <p>Broadcasting is one of NumPy’s most powerful, yet often misunderstood, features. It allows NumPy to perform operations on arrays of different shapes without explicitly creating multiple copies of the smaller array. This saves both memory and computation.</p> <p><strong>The Rules (simplified):</strong></p> <ul> <li>If arrays don’t have the same number of dimensions, prepend 1s to the smaller array’s shape until they do.</li> <li>Dimensions are compatible if they are equal, or if one of them is 1.</li> <li>If dimensions are incompatible, an error is raised.</li> </ul> <p><strong>Example: Centering Data</strong></p> <p>If you have a matrix of data <code class="language-plaintext highlighter-rouge">X</code> (each row is a sample, each column is a feature) and you want to subtract the mean of each feature:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c1"># 1000 samples, 100 features
</span><span class="n">feature_means</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Shape (100,)
</span>
<span class="c1"># Without broadcasting, you might try to tile or loop, which is inefficient.
# With broadcasting:
</span><span class="n">X_centered</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">feature_means</span> <span class="c1"># feature_means is broadcast across rows of X
</span></code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">feature_means</code> (shape <code class="language-plaintext highlighter-rouge">(100,)</code>) is implicitly stretched to match <code class="language-plaintext highlighter-rouge">X</code>’s shape (<code class="language-plaintext highlighter-rouge">(1000, 100)</code>) along the 0th axis. This avoids creating a <code class="language-plaintext highlighter-rouge">(1000, 100)</code> temporary array of means.</p> <h4 id="4-choose-the-right-data-type-dtype">4. Choose the Right Data Type (<code class="language-plaintext highlighter-rouge">dtype</code>)</h4> <p>NumPy arrays hold data of a specific type. By default, it often infers <code class="language-plaintext highlighter-rouge">float64</code> or <code class="language-plaintext highlighter-rouge">int64</code>. However, if your data doesn’t require such precision or range (e.g., pixel values 0-255, small integer counts), using smaller dtypes like <code class="language-plaintext highlighter-rouge">uint8</code>, <code class="language-plaintext highlighter-rouge">int16</code>, <code class="language-plaintext highlighter-rouge">float32</code> can significantly reduce memory footprint and often speed up operations, especially memory-bound ones.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr_float64</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
<span class="n">arr_float32</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">arr_int8</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">int8</span><span class="p">)</span> <span class="c1"># Will wrap around after 127
</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Memory (float64): </span><span class="si">{</span><span class="n">arr_float64</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Memory (float32): </span><span class="si">{</span><span class="n">arr_float32</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Memory (int8): </span><span class="si">{</span><span class="n">arr_int8</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>For large datasets, reducing memory usage means more data fits in cache, leading to faster access.</p> <h4 id="5-in-place-operations-minimize-temporary-arrays">5. In-place Operations: Minimize Temporary Arrays</h4> <p>Many NumPy operations return a <em>new</em> array. For example, <code class="language-plaintext highlighter-rouge">A = A + B</code> creates a new array for the sum and then assigns it back to <code class="language-plaintext highlighter-rouge">A</code>. If <code class="language-plaintext highlighter-rouge">A</code> is very large, this can involve allocating a lot of memory and then deallocating the old <code class="language-plaintext highlighter-rouge">A</code>.</p> <p>Whenever possible, use in-place operations or the <code class="language-plaintext highlighter-rouge">out</code> parameter:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">large_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>
<span class="n">other_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Creates a new array for the sum
# start = time.time(); large_array = large_array + other_array; end = time.time(); print(f"New array: {end-start:.4f}s")
</span>
<span class="c1"># In-place operation - no new array created
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">();</span> <span class="n">large_array</span> <span class="o">+=</span> <span class="n">other_array</span><span class="p">;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">();</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">In-place: </span><span class="si">{</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Using the 'out' parameter (for ufuncs)
</span><span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">empty_like</span><span class="p">(</span><span class="n">large_array</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">();</span> <span class="n">np</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">large_array</span><span class="p">,</span> <span class="n">other_array</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">result_array</span><span class="p">);</span> <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">();</span> <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Out param: </span><span class="si">{</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>While the time difference for a single operation might be small, in-place operations significantly reduce memory churn, which can be critical in memory-bound applications or long-running scripts.</p> <h4 id="6-memory-layout-c-contiguous-vs-fortran-contiguous">6. Memory Layout: C-contiguous vs. Fortran-contiguous</h4> <p>NumPy arrays store data in a specific memory order.</p> <ul> <li> <strong>C-contiguous (row-major):</strong> Elements of a row are contiguous in memory. This is NumPy’s default. <code class="language-plaintext highlighter-rouge">arr.flags['C_CONTIGUOUS']</code> is True.</li> <li> <strong>Fortran-contiguous (column-major):</strong> Elements of a column are contiguous. <code class="language-plaintext highlighter-rouge">arr.flags['F_CONTIGUOUS']</code> is True.</li> </ul> <p>Why does this matter? Accessing data in its native memory order is much faster due to CPU caching. When you transpose an array (<code class="language-plaintext highlighter-rouge">arr.T</code>), you don’t copy the data; you just change the metadata about how to interpret it. The transposed array becomes Fortran-contiguous. If you then iterate over its “rows” (which were original columns), you’ll be jumping around in memory.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Accessing rows (C-contiguous order)
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Row sum (C-contiguous): </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Accessing columns (Fortran-contiguous order in original memory layout)
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># This is slower if not properly optimized internally
</span><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Column sum (accessing non-contiguous): </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Transposing makes it F-contiguous, then sum along new rows (old columns) is fast
</span><span class="n">matrix_T</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">T</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">matrix_T</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Now this is fast because it's row-wise on the transposed (F-contiguous) data
</span><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Column sum (after transpose to C-contiguous): </span><span class="si">{</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>If you know you’ll be repeatedly operating on a transposed view, it’s often beneficial to make a contiguous copy: <code class="language-plaintext highlighter-rouge">matrix.T.copy()</code> or <code class="language-plaintext highlighter-rouge">np.ascontiguousarray(matrix.T)</code>.</p> <h4 id="7-measure-dont-guess-timeit">7. Measure, Don’t Guess! (<code class="language-plaintext highlighter-rouge">%timeit</code>)</h4> <p>This is perhaps the <em>most important</em> lesson. I learned early on that my intuition about what would be fast or slow was often wrong. Always measure!</p> <p>In Jupyter notebooks or IPython, <code class="language-plaintext highlighter-rouge">%timeit</code> is your best friend:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">))</span>
<span class="o">%</span><span class="n">timeit</span> <span class="nf">sum</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">))</span> <span class="c1"># Don't do this!
</span></code></pre></div></div> <p>For more complex scripts, Python’s built-in <code class="language-plaintext highlighter-rouge">cProfile</code> module or external tools like <code class="language-plaintext highlighter-rouge">line_profiler</code> can help pinpoint performance bottlenecks. Without measurement, you’re just optimizing blindly.</p> <h3 id="the-journey-continues">The Journey Continues</h3> <p>My journey into NumPy optimization taught me that true mastery isn’t just about knowing the syntax, but understanding the underlying mechanisms. It’s about respecting the speed that NumPy offers by using it as intended: with vectorized operations, mindful memory management, and judicious data typing.</p> <p>There will always be new challenges, new datasets, and new algorithms. But with these strategies in my toolkit, I no longer dread the “slow Python” myth. Instead, I embrace the challenge, knowing that with a little thought and profiling, I can unleash the full speed demon within my NumPy code.</p> <p>So, go forth and experiment! Profile your code, question your loops, and embrace the power of NumPy. Your faster scripts (and happier self) will thank you.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/cracking-the-ai-black-box-why-explainable-ai-xai-i/">Cracking the AI Black Box: Why Explainable AI (XAI) is Our Superpower</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/the-secret-life-of-states-how-markov-chains-predic/">The Secret Life of States: How Markov Chains Predict Our Next Move (Without Remembering the Past!)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/gradient-descent-unpacking-the-engine-of-machine-l/">Gradient Descent: Unpacking the Engine of Machine Learning</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Adarsh Nair. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/blog/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/blog/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/blog/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/blog/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/blog/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/blog/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/blog/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/blog/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/blog/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/blog/assets/js/search-data.js"></script> <script src="/blog/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>