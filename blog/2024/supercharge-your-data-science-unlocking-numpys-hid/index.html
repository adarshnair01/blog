<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Supercharge Your Data Science: Unlocking NumPy's Hidden Optimization Secrets | Adarsh Nair </title> <meta name="author" content="Adarsh Nair"> <meta name="description" content="A deep dive into machine learning, AI, and data science. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/blog/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/blog/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/blog/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/blog/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://adarshnair.online/blog/blog/blog/2024/supercharge-your-data-science-unlocking-numpys-hid/"> <script src="/blog/assets/js/theme.js?v=5fea5159b787642c1bbc1f334d60f883"></script> <link defer rel="stylesheet" href="/blog/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="https://adarshnair.online" rel="external nofollow noopener" target="_blank"> Adarsh Nair </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/blog/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/index.html">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/cv/">CV </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/repositories/">repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Supercharge Your Data Science: Unlocking NumPy's Hidden Optimization Secrets</h1> <p class="post-meta"> Created on September 02, 2024 by Adarsh Nair </p> <p class="post-tags"> <a href="/blog/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/blog/tag/numpy"> <i class="fa-solid fa-hashtag fa-sm"></i> NumPy</a>   <a href="/blog/blog/tag/optimization"> <i class="fa-solid fa-hashtag fa-sm"></i> Optimization</a>   <a href="/blog/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> Python</a>   <a href="/blog/blog/tag/data-science"> <i class="fa-solid fa-hashtag fa-sm"></i> Data Science</a>   <a href="/blog/blog/tag/performance"> <i class="fa-solid fa-hashtag fa-sm"></i> Performance</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>My journey into data science, much like many of yours I imagine, began with the comforting embrace of Python. It’s so intuitive, so readable, so… <em>slow</em> sometimes. I remember the frustration of watching my scripts chug along for what felt like an eternity when processing even moderately sized datasets. It was like trying to run a marathon in flip-flops. Then, I met NumPy, and it was like someone handed me a pair of high-performance running shoes.</p> <p>But here’s the kicker: even with those fancy shoes, you still need to know <em>how</em> to run efficiently. Simply using NumPy isn’t always enough; using it <em>optimally</em> is where the real magic happens. This isn’t just about shaving off milliseconds; it’s about transforming hours into minutes, enabling you to iterate faster, experiment more, and tackle problems that were previously out of reach due to computational constraints.</p> <p>So, grab your virtual notebook! Today, we’re going to dive deep into the secrets of NumPy optimization. We’ll explore <em>why</em> it’s fast, and more importantly, <em>how</em> you can write code that leverages its power to the fullest. Think of this as your personal guide to becoming a NumPy performance wizard.</p> <h3 id="the-numpy-superpower-why-its-fast-when-used-right">The NumPy Superpower: Why It’s Fast (When Used Right)</h3> <p>Before we optimize, let’s briefly understand what makes NumPy so powerful in the first place. At its heart, NumPy arrays are designed to store large amounts of numerical data efficiently. Unlike standard Python lists, which can hold elements of different types and store them scattered across memory, NumPy arrays:</p> <ol> <li> <strong>Store Homogeneous Data</strong>: Every element in a NumPy array has the same data type (e.g., all integers, all floats). This allows for compact storage.</li> <li> <strong>Contiguous Memory Allocation</strong>: The elements of a NumPy array are stored in a single, contiguous block of memory. This is crucial for performance because it allows the CPU to fetch data very quickly (what we call “cache locality”).</li> <li> <strong>C/Fortran Backend</strong>: Many of NumPy’s operations are not performed in Python at all! They are implemented in highly optimized, low-level languages like C or Fortran. When you call <code class="language-plaintext highlighter-rouge">np.sum()</code> or <code class="language-plaintext highlighter-rouge">np.dot()</code>, you’re essentially calling highly optimized C functions behind the scenes.</li> </ol> <p>This is the fundamental reason why Python loops over NumPy arrays are painfully slow compared to using NumPy’s built-in functions. Python loops operate on individual Python objects, incurring significant overhead, while NumPy’s internal loops are blazing fast C loops.</p> <h3 id="the-golden-rule-vectorization">The Golden Rule: Vectorization</h3> <p>If there’s one principle you take away today, let it be <strong>vectorization</strong>. It’s the cornerstone of efficient NumPy programming. Vectorization means performing operations on entire arrays at once, rather than iterating through elements one by one using Python loops.</p> <p>Let’s illustrate with a simple example: adding two arrays.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">timeit</span>

<span class="c1"># Option 1: Python Loop (Don't do this!)
</span><span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span>
<span class="n">list1</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
<span class="n">list2</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">add_with_loop</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">l2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">l1</span><span class="p">))]</span>

<span class="n">python_loop_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">add_with_loop</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Python loop time: </span><span class="si">{</span><span class="n">python_loop_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Option 2: NumPy Vectorization (Do this!)
</span><span class="n">arr1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_with_numpy</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span>

<span class="n">numpy_vector_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">add_with_numpy</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">NumPy vectorized time: </span><span class="si">{</span><span class="n">numpy_vector_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>When I ran this on my machine, the Python loop took around 1.2 seconds, while the NumPy version completed in about 0.01 seconds. That’s a <em>100x speedup</em>! This dramatic difference stems from NumPy’s ability to execute element-wise operations as a single, highly optimized C operation.</p> <p>Mathematically, if we have two vectors $\mathbf{a} = [a_1, a_2, …, a_n]$ and $\mathbf{b} = [b_1, b_2, …, b_n]$, their sum is $\mathbf{c} = \mathbf{a} + \mathbf{b}$, where each element $c_i = a_i + b_i$. NumPy handles this element-wise operation incredibly efficiently.</p> <p><strong>Analogy</strong>: Think of it like a factory. A Python loop is like an individual worker taking one item, processing it, and moving to the next. Vectorization is like having an assembly line with specialized machines that process thousands of items simultaneously.</p> <h3 id="memory-matters-avoid-unnecessary-copying">Memory Matters: Avoid Unnecessary Copying</h3> <p>NumPy is smart about memory, but it’s easy to accidentally force it to make copies of arrays, which can be expensive, especially for large datasets. Operations like slicing <em>can</em> return a “view” of the original array (meaning no new memory is allocated), but sometimes they return a copy. Knowing the difference can save you a lot of performance headaches.</p> <p>A “view” is like looking through a window at the original data; any changes you make through the view will affect the original array. A “copy” is like taking a photograph; changes to the photo don’t affect the original scene.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create a large array
</span><span class="n">large_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Case 1: Slicing (often a view)
</span><span class="n">view_array</span> <span class="o">=</span> <span class="n">large_array</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Is view_array a view? </span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">may_share_memory</span><span class="p">(</span><span class="n">large_array</span><span class="p">,</span> <span class="n">view_array</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># True
</span>
<span class="c1"># If you modify view_array, large_array will change
</span><span class="n">view_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">999</span>
<span class="nf">print</span><span class="p">(</span><span class="n">large_array</span><span class="p">[</span><span class="mi">100</span><span class="p">])</span> <span class="c1"># Will be 999
</span>
<span class="c1"># Case 2: Explicit Copy (always a copy)
</span><span class="n">copied_array</span> <span class="o">=</span> <span class="n">large_array</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">200</span><span class="p">].</span><span class="nf">copy</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Is copied_array a view? </span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">may_share_memory</span><span class="p">(</span><span class="n">large_array</span><span class="p">,</span> <span class="n">copied_array</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># False
</span>
<span class="c1"># Modifying copied_array won't affect large_array
</span><span class="n">copied_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">111</span>
<span class="nf">print</span><span class="p">(</span><span class="n">large_array</span><span class="p">[</span><span class="mi">100</span><span class="p">])</span> <span class="c1"># Still 999
</span>
<span class="c1"># Case 3: Advanced Indexing (always a copy)
# When you use a list of indices or a boolean array
</span><span class="n">indexed_array</span> <span class="o">=</span> <span class="n">large_array</span><span class="p">[[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">300</span><span class="p">]]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Is indexed_array a view? </span><span class="si">{</span><span class="n">np</span><span class="p">.</span><span class="nf">may_share_memory</span><span class="p">(</span><span class="n">large_array</span><span class="p">,</span> <span class="n">indexed_array</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># False
</span></code></pre></div></div> <p><strong>Key takeaway</strong>: Be mindful of when NumPy creates copies. Explicitly use <code class="language-plaintext highlighter-rouge">.copy()</code> when you <em>need</em> an independent version of the data. Otherwise, try to work with views when possible. The <code class="language-plaintext highlighter-rouge">.flags['OWNDATA']</code> attribute can also tell you if an array owns its data (i.e., it’s not a view of another array).</p> <h3 id="the-right-tool-for-the-job-data-types-dtype">The Right Tool for the Job: Data Types (<code class="language-plaintext highlighter-rouge">dtype</code>)</h3> <p>NumPy arrays are homogeneous, meaning all elements have the same data type (<code class="language-plaintext highlighter-rouge">dtype</code>). Choosing the right <code class="language-plaintext highlighter-rouge">dtype</code> can significantly impact memory usage and performance, especially for very large arrays. Smaller data types require less memory, which means more data can fit into your CPU’s cache, leading to faster access.</p> <p>Common dtypes include <code class="language-plaintext highlighter-rouge">int8</code>, <code class="language-plaintext highlighter-rouge">int16</code>, <code class="language-plaintext highlighter-rouge">int32</code>, <code class="language-plaintext highlighter-rouge">int64</code>, <code class="language-plaintext highlighter-rouge">float32</code>, <code class="language-plaintext highlighter-rouge">float64</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Define a large array
</span><span class="n">large_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Default dtype (usually int64 on 64-bit systems)
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Default dtype: </span><span class="si">{</span><span class="n">large_data</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">, Size: </span><span class="si">{</span><span class="n">large_data</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Specify a smaller dtype
</span><span class="n">smaller_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">int32</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">int32 dtype: </span><span class="si">{</span><span class="n">smaller_data</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">, Size: </span><span class="si">{</span><span class="n">smaller_data</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># For floating-point numbers
</span><span class="n">float64_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">float64 dtype: </span><span class="si">{</span><span class="n">float64_data</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">, Size: </span><span class="si">{</span><span class="n">float64_data</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>

<span class="n">float32_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">float32 dtype: </span><span class="si">{</span><span class="n">float32_data</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">, Size: </span><span class="si">{</span><span class="n">float32_data</span><span class="p">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> MB</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Notice how <code class="language-plaintext highlighter-rouge">int32</code> uses half the memory of <code class="language-plaintext highlighter-rouge">int64</code>, and <code class="language-plaintext highlighter-rouge">float32</code> uses half the memory of <code class="language-plaintext highlighter-rouge">float64</code>. If your data doesn’t require the full range or precision of a larger data type (e.g., your integers never exceed 32,767, you could use <code class="language-plaintext highlighter-rouge">int16</code>), using a smaller <code class="language-plaintext highlighter-rouge">dtype</code> is a free performance win.</p> <h3 id="broadcasting-the-smart-way-to-combine-arrays">Broadcasting: The Smart Way to Combine Arrays</h3> <p>Broadcasting is one of NumPy’s most powerful and often misunderstood features. It describes how NumPy treats arrays with different shapes during arithmetic operations. It allows you to perform operations between arrays of different sizes without explicitly making copies of the smaller array to match the larger one.</p> <p>The simplest example is adding a scalar to an array: $\mathbf{a} = [a_1, a_2, …, a_n]$ $\mathbf{a} + k = [a_1+k, a_2+k, …, a_n+k]$</p> <p>NumPy effectively “stretches” the scalar $k$ to match the shape of $\mathbf{a}$ without actually allocating new memory for $k$.</p> <p>More complex broadcasting rules apply when combining arrays of different dimensions:</p> <ol> <li>If the arrays don’t have the same number of dimensions, the shape of the smaller array is padded with ones on its left side.</li> <li>The arrays are compatible if, for each dimension, their sizes are equal, or one of them is 1.</li> <li>Dimensions with size 1 are stretched to match the other array’s size.</li> </ol> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Scalar to array
</span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">5</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Scalar broadcasting: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># [6 7 8]
</span>
<span class="c1"># 1D array to 2D array
</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="n">row_vector</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>

<span class="c1"># NumPy effectively broadcasts row_vector across each row of the matrix
</span><span class="n">result_matrix</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">+</span> <span class="n">row_vector</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">1D to 2D broadcasting:</span><span class="se">\n</span><span class="si">{</span><span class="n">result_matrix</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># Output:
# [[11 22 33]
#  [14 25 36]
#  [17 28 39]]
</span></code></pre></div></div> <p>Broadcasting enables concise code and avoids explicit loops, making your code faster and more readable. Always try to leverage broadcasting instead of manually creating intermediate arrays or iterating.</p> <h3 id="universal-functions-ufuncs-the-built-in-speed-demons">Universal Functions (ufuncs): The Built-in Speed Demons</h3> <p>NumPy’s “universal functions” (ufuncs) are vectorized wrappers around C functions that perform element-wise operations on arrays. You’ve already used them implicitly when you write <code class="language-plaintext highlighter-rouge">arr1 + arr2</code> (which calls <code class="language-plaintext highlighter-rouge">np.add</code>) or <code class="language-plaintext highlighter-rouge">np.sqrt(arr)</code>.</p> <p>Ufuncs are incredibly fast because they are highly optimized at the C level. When possible, always prefer a NumPy ufunc over writing your own Python function, even if your Python function <em>looks</em> vectorized.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Calculate sine of each element
</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Using np.sin ufunc
</span><span class="n">ufunc_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Ufunc (np.sin) time: </span><span class="si">{</span><span class="n">ufunc_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># A slightly less optimal way (still vectorized, but not direct ufunc)
# This might sometimes be slower due to intermediate array creations or less optimized paths
</span><span class="n">custom_func_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">number</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Combined operation time: </span><span class="si">{</span><span class="n">custom_func_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Many ufuncs also accept an <code class="language-plaintext highlighter-rouge">out</code> argument, allowing you to perform calculations in-place, which can save memory by avoiding the creation of new arrays: <code class="language-plaintext highlighter-rouge">np.add(arr1, arr2, out=arr1)</code> will store the result of <code class="language-plaintext highlighter-rouge">arr1 + arr2</code> back into <code class="language-plaintext highlighter-rouge">arr1</code>.</p> <h3 id="beware-of-implicit-loops-the-sneaky-performance-killer">Beware of Implicit Loops (The Sneaky Performance Killer)</h3> <p>Even when using NumPy, it’s possible to inadvertently write code that forces Python to loop, negating all the benefits of vectorization. This often happens with conditional logic or complex element-wise assignments.</p> <p>Consider applying a threshold: if an element is less than 0.5, set it to 0.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Option 1: Python loop (Slow!)
</span><span class="k">def</span> <span class="nf">threshold_loop</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">empty_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="n">python_threshold_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">threshold_loop</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">copy</span><span class="p">()),</span> <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Python loop threshold time: </span><span class="si">{</span><span class="n">python_threshold_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Option 2: Boolean Indexing (Fast!)
</span><span class="k">def</span> <span class="nf">threshold_boolean_indexing</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">arr</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">arr</span>

<span class="n">boolean_threshold_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">threshold_boolean_indexing</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">copy</span><span class="p">()),</span> <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Boolean indexing threshold time: </span><span class="si">{</span><span class="n">boolean_threshold_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># Option 3: np.where (Also Fast and more general)
</span><span class="k">def</span> <span class="nf">threshold_np_where</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">arr</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

<span class="n">where_threshold_time</span> <span class="o">=</span> <span class="n">timeit</span><span class="p">.</span><span class="nf">timeit</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nf">threshold_np_where</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="nf">copy</span><span class="p">()),</span> <span class="n">number</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">np.where threshold time: </span><span class="si">{</span><span class="n">where_threshold_time</span><span class="si">:</span><span class="p">.</span><span class="mi">6</span><span class="n">f</span><span class="si">}</span><span class="s"> seconds</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Again, the difference is stark. The Python loop is orders of magnitude slower. <code class="language-plaintext highlighter-rouge">np.where()</code> is particularly powerful for conditional assignments, mapping to the mathematical piecewise function: $f(x) = \begin{cases} \text{value_if_true} &amp; \text{if condition} \ \text{value_if_false} &amp; \text{otherwise} \end{cases}$</p> <h3 id="advanced-thoughts-a-glimpse-beyond">Advanced Thoughts (A Glimpse Beyond)</h3> <p>While these principles cover the vast majority of NumPy optimization, for those truly pushing the boundaries, consider:</p> <ul> <li> <strong>Memory Layout (<code class="language-plaintext highlighter-rouge">order='C'</code> vs <code class="language-plaintext highlighter-rouge">order='F'</code>)</strong>: NumPy arrays can be stored in C-contiguous (row-major) or Fortran-contiguous (column-major) order. Accessing elements in a way that aligns with their memory layout can lead to better cache performance, especially in multi-dimensional arrays. Most Python users default to C-order.</li> <li> <strong>Numba and Cython</strong>: For incredibly specific, hot-spot functions where even optimized NumPy falls short, tools like Numba (which compiles Python code to fast machine code at runtime) or Cython (which allows you to write C extensions for Python) can provide further speedups. But always profile first; don’t reach for these unless you’ve exhausted pure NumPy optimizations.</li> </ul> <h3 id="my-final-thoughts-cultivating-an-optimization-mindset">My Final Thoughts: Cultivating an Optimization Mindset</h3> <p>Optimizing NumPy isn’t just about memorizing a list of functions; it’s about cultivating a different way of thinking when you approach numerical problems in Python. It’s about shifting from an element-by-element mindset to an array-wide, vectorized perspective.</p> <p>Whenever you find yourself about to write a <code class="language-plaintext highlighter-rouge">for</code> loop that iterates over a NumPy array, pause. Ask yourself: “Can I do this with a NumPy function? Can I use broadcasting? Can I use boolean indexing or <code class="language-plaintext highlighter-rouge">np.where</code>?” More often than not, the answer is yes, and your code will thank you with lightning-fast execution.</p> <p>By embracing these principles, you’re not just writing faster code; you’re developing a deeper understanding of how modern computational libraries work, a skill invaluable in any data science or machine learning role. So go forth, experiment, profile your code, and unlock the true power of NumPy! Your future self (and your CPU) will definitely appreciate it.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/cracking-the-ai-black-box-why-explainable-ai-xai-i/">Cracking the AI Black Box: Why Explainable AI (XAI) is Our Superpower</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/the-secret-life-of-states-how-markov-chains-predic/">The Secret Life of States: How Markov Chains Predict Our Next Move (Without Remembering the Past!)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/blog/2026/gradient-descent-unpacking-the-engine-of-machine-l/">Gradient Descent: Unpacking the Engine of Machine Learning</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Adarsh Nair. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/blog/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/blog/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/blog/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/blog/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/blog/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/blog/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/blog/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/blog/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/blog/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/blog/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/blog/assets/js/search-data.js"></script> <script src="/blog/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> </body> </html>